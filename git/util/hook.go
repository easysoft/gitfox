// Copyright (c) 2023-2024 北京渠成软件有限公司(Beijing Qucheng Software Co., Ltd. www.qucheng.com) All rights reserved.
// Use of this source code is covered by the following dual licenses:
// (1) Z PUBLIC LICENSE 1.2 (ZPL 1.2)
// (2) Affero General Public License 3.0 (AGPL 3.0)
// license that can be found in the LICENSE file.

package util

import (
	"fmt"

	"github.com/easysoft/gitfox/git/enum"
)

func GetHookTemplates() (hookNames, hookTpls, giteaHookTpls []string) {
	hookNames = []string{"pre-receive", "update", "post-receive"}
	hookTpls = []string{
		// for pre-receive
		fmt.Sprintf(`#!/usr/bin/env %s
# AUTO GENERATED BY GITFOX, DO NOT MODIFY
data=$(cat)
exitcodes=""
hookname=$(basename $0)
GIT_DIR=${GIT_DIR:-$(dirname $0)/..}

for hook in ${GIT_DIR}/hooks/${hookname}.d/*; do
  test -x "${hook}" && test -f "${hook}" || continue
  echo "${data}" | "${hook}"
  exitcodes="${exitcodes} $?"
done

for i in ${exitcodes}; do
  [ ${i} -eq 0 ] || exit ${i}
done
`, enum.ScriptType),

		// for update
		fmt.Sprintf(`#!/usr/bin/env %s
# AUTO GENERATED BY GITFOX, DO NOT MODIFY
exitcodes=""
hookname=$(basename $0)
GIT_DIR=${GIT_DIR:-$(dirname $0/..)}

for hook in ${GIT_DIR}/hooks/${hookname}.d/*; do
	test -x "${hook}" && test -f "${hook}" || continue
	"${hook}" $1 $2 $3
	exitcodes="${exitcodes} $?"
done

for i in ${exitcodes}; do
	[ ${i} -eq 0 ] || exit ${i}
done
`, enum.ScriptType),

		// for post-receive
		fmt.Sprintf(`#!/usr/bin/env %s
# AUTO GENERATED BY GITFOX, DO NOT MODIFY
data=$(cat)
exitcodes=""
hookname=$(basename $0)
GIT_DIR=${GIT_DIR:-$(dirname $0)/..}

for hook in ${GIT_DIR}/hooks/${hookname}.d/*; do
  test -x "${hook}" && test -f "${hook}" || continue
  echo "${data}" | "${hook}"
  exitcodes="${exitcodes} $?"
done

for i in ${exitcodes}; do
  [ ${i} -eq 0 ] || exit ${i}
done
`, enum.ScriptType),
	}

	giteaHookTpls = []string{
		// for pre-receive
		fmt.Sprintf(`#!/usr/bin/env %s
# AUTO GENERATED BY GITFOX, DO NOT MODIFY
%s hooks pre-receive
`, enum.ScriptType, loadGitfoxBinPath()),

		// for update
		fmt.Sprintf(`#!/usr/bin/env %s
# AUTO GENERATED BY GITFOX, DO NOT MODIFY
refname="$1"
oldrev="$2"
newrev="$3"

get_mail() {
	mail=""
	author_email=$(git log -1 --pretty=format:'%%ae' $newrev)
	author_email=$(echo "$author_email" | tr '[:upper:]' '[:lower:]')
	email_username=$(echo "$author_email" | cut -d '@' -f 1)
	mail=$(echo "$email_username" | tr -d '.')
	echo "$mail"
}

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/for/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		branch_number=$(echo $refname | sed 's!refs/for/!!')
		# branch_number=$(echo $branch_number | tr '/' '-')
		new_branch="refs/heads/ztflow-$branch_number"
		mail=$(get_mail)
		[ ! -z "$mail" ] && new_branch="refs/heads/ztflow-$mail-$branch_number"
		# if git show-ref --verify --quiet $new_branch; then
		# echo "Error: Branch $new_branch already exists."
		# exit 1
		# fi
		git update-ref $new_branch $newrev
		if [ $? -ne 0 ]; then
				echo "Error: Failed to create branch $new_branch."
				exit 1
		fi
		;;
		*)
			exit 0
		;;
esac
exit 0
`, enum.ScriptType),

		// for post-receive
		fmt.Sprintf(`#!/usr/bin/env %s
# AUTO GENERATED BY GITEA, DO NOT MODIFY
%s hooks post-receive
`, enum.ScriptType, loadGitfoxBinPath()),
	}
	return hookNames, hookTpls, giteaHookTpls
}
